<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhubokai.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本节讲解了逆向分析中，C++在反汇编中的特征以及 mfc 程序逆向的方式">
<meta property="og:type" content="article">
<meta property="og:title" content="C++反汇编分析">
<meta property="og:url" content="https://www.zhubokai.com/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html">
<meta property="og:site_name" content="Demonsのblog">
<meta property="og:description" content="本节讲解了逆向分析中，C++在反汇编中的特征以及 mfc 程序逆向的方式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/1.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/2.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/3.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/4.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/5.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/6.png">
<meta property="og:image" content="https://www.zhubokai.com/images/asm/7.png">
<meta property="article:published_time" content="2020-10-04T08:47:47.000Z">
<meta property="article:modified_time" content="2021-01-01T00:49:10.853Z">
<meta property="article:author" content="Demons">
<meta property="article:tag" content="逆向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zhubokai.com/images/asm/1.png">

<link rel="canonical" href="https://www.zhubokai.com/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++反汇编分析 | Demonsのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Demonsのblog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Demonsのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">祸莫大于不知足;咎莫大于欲得。故知足之足，常足矣</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-top">

    <a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>排行榜</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zhubokai.com/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Demons">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Demonsのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++反汇编分析
        </h1>

        <div class="post-meta">
		
		
  <i class="fa fa-thumb-tack"></i>
  <font color="7D26CD">置顶</font>
  <span class="post-meta-divider">|</span>

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-04 16:47:47" itemprop="dateCreated datePublished" datetime="2020-10-04T16:47:47+08:00">2020-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 08:49:10" itemprop="dateModified" datetime="2021-01-01T08:49:10+08:00">2021-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          
            <span id="/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html" class="post-meta-item leancloud_visitors" data-flag-title="C++反汇编分析" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count">℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>本节讲解了逆向分析中，C++在反汇编中的特征以及 <code>mfc</code> 程序逆向的方式</li>
</ul>
<a id="more"></a>



<h1 id="使用IDA分析程序"><a href="#使用IDA分析程序" class="headerlink" title="使用IDA分析程序"></a>使用IDA分析程序</h1><h2 id="开辟函数栈帧"><a href="#开辟函数栈帧" class="headerlink" title="开辟函数栈帧"></a>开辟函数栈帧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     esp, 0E4h       ; 开辟函数的栈帧，栈帧大小为 0xe4</span><br></pre></td></tr></table></figure>



<h2 id="保存寄存器环境"><a href="#保存寄存器环境" class="headerlink" title="保存寄存器环境"></a>保存寄存器环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push    ebx</span><br><span class="line">push    esi</span><br><span class="line">push    edi             ; 保存寄存器环境，因为当前函数使用了这些寄存器，如果不保存函数内部对寄存器的修改会直接影响到外部函数，可能会导致程序出现问题</span><br></pre></td></tr></table></figure>



<h2 id="初始化局部变量"><a href="#初始化局部变量" class="headerlink" title="初始化局部变量"></a>初始化局部变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea     edi, [ebp+var_E4]</span><br><span class="line">mov     ecx, 39h</span><br><span class="line">mov     eax, 0CCCCCCCCh</span><br><span class="line">rep stosd               ; 初始化函数的栈帧保存的是 0xCCCCCCCC，因为有这个设置，所以未初始化的局部变量保存的就是 &quot;烫烫烫&quot;</span><br></pre></td></tr></table></figure>



<h2 id="初始化安全cookie"><a href="#初始化安全cookie" class="headerlink" title="初始化安全cookie"></a>初始化安全cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, ___security_cookie</span><br><span class="line">xor     eax, ebp</span><br><span class="line">mov     [ebp+var_4], eax ; 编译器提供一个随机的安全cookie，以当前的ebp为key对安全cookie进行加密操作并保存到ebp+var_4的位置</span><br></pre></td></tr></table></figure>



<h2 id="检测是否是库函数"><a href="#检测是否是库函数" class="headerlink" title="检测是否是库函数"></a>检测是否是库函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, offset unk_41D007</span><br><span class="line">call    j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x)   </span><br></pre></td></tr></table></figure>



<h2 id="检测堆栈平衡"><a href="#检测堆栈平衡" class="headerlink" title="检测堆栈平衡"></a>检测堆栈平衡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp     esi, esp</span><br><span class="line">call    j___RTC_CheckEsp ; 检查堆栈是否平衡，通常出现在需要平衡堆栈的函数调用之后，会在函数调用之前先保存 esp 的值，函数调用之后进行比对，如果不同就会引发程序的崩溃</span><br></pre></td></tr></table></figure>



<h2 id="恢复寄存器环境"><a href="#恢复寄存器环境" class="headerlink" title="恢复寄存器环境"></a>恢复寄存器环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xor     eax, eax</span><br><span class="line">pop     edi</span><br><span class="line">pop     esi</span><br><span class="line">pop     ebx             ; 恢复之前保存的寄存器环境</span><br><span class="line">add     esp, 0E4h</span><br></pre></td></tr></table></figure>



<h2 id="检测数组是否越界"><a href="#检测数组是否越界" class="headerlink" title="检测数组是否越界"></a>检测数组是否越界</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xor     eax, eax</span><br><span class="line">push    edx</span><br><span class="line">mov     ecx, ebp</span><br><span class="line">push    eax</span><br><span class="line">lea     edx, dword_411420</span><br><span class="line">call    j_@_RTC_CheckStackVars@8 ;检测数组是否越界的函数，通常会在数组的赋值操作之后，原理就是在初始化堆栈的时候，编译器将栈帧的所有内容写作了0xcc，所以数组的结尾应该就是0xcc，假设越界赋值，后面的0xcc就被覆盖，这个函数的作用就是检查有没有被覆盖是为了防止缓冲区溢出攻击而产生的机制，应该叫做 GS</span><br></pre></td></tr></table></figure>



<h2 id="关闭栈帧"><a href="#关闭栈帧" class="headerlink" title="关闭栈帧"></a>关闭栈帧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp     ebp, esp</span><br><span class="line">call    j___RTC_CheckEsp</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">retn                    ; 函数要保证执行前后的堆栈是平衡的，所以这里需要关闭栈帧</span><br><span class="line">endp</span><br></pre></td></tr></table></figure>



<h1 id="C-反汇编"><a href="#C-反汇编" class="headerlink" title="C++反汇编"></a>C++反汇编</h1><h2 id="基本常量类型"><a href="#基本常量类型" class="headerlink" title="基本常量类型"></a>基本常量类型</h2><ul>
<li><p><strong><em>浮点常量</em></strong></p>
<ul>
<li>被保存在常量区，初始化时需要通过 <code>xmm</code> 寄存器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span>  fNum = <span class="number">1.5</span>;        <span class="comment">// 浮点常量</span></span><br><span class="line"><span class="comment">// movss       xmm0, dword ptr ds : [00217BD8h]</span></span><br><span class="line"><span class="comment">// movss       dword ptr[ebp - 38h], xmm0</span></span><br><span class="line"><span class="comment">// mov         dword ptr[ebp - 4Ch], 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>字符串常量</em></strong></p>
<ul>
<li>常量字符串保存在常量区，赋值使用的实际是所在的地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* szHello = <span class="string">&quot;Hello world&quot;</span>;            <span class="comment">// 字符串常量</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_2C], offset aHelloWorld(字符串地址)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>字符</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>  ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// mov     [ebp+var_1D], 41h ;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>整型</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNum = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// mov     [ebp+var_8], 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>布尔常量</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> bRet = <span class="literal">true</span>;         <span class="comment">// 布尔常量</span></span><br><span class="line"><span class="comment">// mov         byte ptr[ebp - 5], 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>字符串的初始化</em></strong></p>
<ul>
<li>字符串数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szStr[<span class="number">100</span>] = &#123; <span class="string">&quot;szStr[100] Hello world&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// mov     esi, offset aSzstr100HelloW ; &quot;szStr[100] Hello world&quot;</span></span><br><span class="line"><span class="comment">// lea     edi, [ebp+var_6C]</span></span><br><span class="line"><span class="comment">// rep movsd</span></span><br><span class="line"><span class="comment">// movsw</span></span><br><span class="line"><span class="comment">// movsb</span></span><br><span class="line"><span class="comment">// push    4Dh ; &#x27;M&#x27;       ; Size</span></span><br><span class="line"><span class="comment">// push    0               ; Val</span></span><br><span class="line"><span class="comment">// lea     eax, [ebp+Dst]</span></span><br><span class="line"><span class="comment">// push    eax             ; Dst</span></span><br><span class="line"><span class="comment">// call    j_memset         ; 将数组没有给定值的其他部分初始化为0    </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>指针和引用</em></strong></p>
</li>
<li><p>引用类型的参数也占内存空间，其中保存的数据是一个地址值</p>
</li>
<li><p>指针和引用难以区分，在反汇编下，没有引用这种数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// mov     [ebp+var_C], 0Ah</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pnumber = &amp;number;</span><br><span class="line">    <span class="comment">// lea     eax, [ebp+var_C]</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_18], eax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; rnumber = number;</span><br><span class="line">    <span class="comment">// lea     eax, [ebp+var_C]</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_24], eax</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>常量</em></strong></p>
</li>
<li><p>#define 是一个真常量，而 <code>const</code> 却是由编译器判断实现的常量，是一个假常量</p>
</li>
<li><p>使用 <code>const</code> 定义的变量，最终还是一个变量，只是在编译器内进行了检查，发现有修改则报错 </p>
</li>
<li><p>由于编译器在编译期间对 <code>const</code> 变量进行检查，因此被 <code>const</code> 修饰过的变量是可以修改的，利用指针获取到 <code>const</code> 修饰过的变量地址，强制将指针的 <code>const</code> 修饰去掉，就可以修改对应的数据内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  100   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nCount = SIZE;    <span class="comment">// const常量</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_8], 64h ;</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nConst = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// mov     [ebp+var_C], 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pConst = (<span class="keyword">int</span>*)&amp;nConst;</span><br><span class="line"><span class="comment">// lea     eax, [ebp+var_C]     ; 获取 ebp+var_C 地址并存入 eax 中</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_18], eax    ; 将 eax 中的数据赋值到地址 ebp+var_18 处</span></span><br><span class="line"></span><br><span class="line">*pConst = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// mov     eax, [ebp+var_18]    ; 获取 ebp+var_18 中的数据并存入 eax</span></span><br><span class="line"><span class="comment">// mov     dword ptr [eax], 6   ; 将地址 ebp+var_18 中保存的数据修改为 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nVar = nConst;</span><br><span class="line"><span class="comment">// mov     [ebp+var_24], 5      ; 将 5 赋值到地址 ebp+var_24 处</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h2><ul>
<li><p><strong><em>全局变量</em></strong></p>
<ul>
<li>全局变量是通过立即数来访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_nNum1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// mov     ecx, dword_41A000</span></span><br><span class="line"><span class="comment">// push    ecx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nNum2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// mov     eax, dword_41A004</span></span><br><span class="line"><span class="comment">// push    eax</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, g_nNum1, g_nNum2);</span><br><span class="line">    <span class="comment">// push    offset aDD       ; &quot;%d %d&quot;</span></span><br><span class="line">    <span class="comment">// call    sub_41104B       ; 调用 printf 函数</span></span><br><span class="line">    <span class="comment">// add     esp, 0Ch         ; 平衡 printf 函数的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>局部变量</em></strong></p>
<ul>
<li>局部变量的访问是通过栈指针相对间接访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nOne = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// mov     [ebp+var_C], 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nTwo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// mov     [ebp+var_18], 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;nOne, &amp;nTwo);</span><br><span class="line"><span class="comment">// push    offset aDD      ; &quot;%d %d&quot;</span></span><br><span class="line"><span class="comment">// call    sub_41104B</span></span><br><span class="line"><span class="comment">// add     esp, 0Ch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>局部静态变量</em></strong></p>
<ul>
<li>局部静态变量不会随作用域的结束而消失，并且在未进入作用域之前就已经存在，其生命周期和全局变量相同</li>
<li>局部静态变量和全局变量都保存在执行文件中的数据区中，局部静态变量会预先被作为全局变量处理，而它的初始化部分只是在做赋值操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowStatic</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> snNumber = nNumber;</span><br><span class="line">    <span class="comment">// mov     eax, TlsIndex</span></span><br><span class="line">    <span class="comment">// mov     ecx, large fs:2Ch</span></span><br><span class="line">    <span class="comment">// mov     edx, [ecx+eax*4]</span></span><br><span class="line">    <span class="comment">// mov     eax, dword_41B150            ; 此线程是局部静态变量的初始化标志，初始为0</span></span><br><span class="line">    <span class="comment">// cmp     eax, [edx+104h]              ; [edx+104h]--&gt;[[ecx+eax*4]+104h]--&gt;[[fs:wch]+TlsIndex+104h]</span></span><br><span class="line">    <span class="comment">// jle     short loc_41185F             ; 判断是否已经初始化</span></span><br><span class="line">    <span class="comment">// push    offset dword_41B150</span></span><br><span class="line">    <span class="comment">// call    j___Init_thread_header       ; 保证局部的静态对象的初始化</span></span><br><span class="line">    <span class="comment">// add     esp, 4</span></span><br><span class="line">    <span class="comment">// cmp     dword_41B150, 0FFFFFFFFh     ; 判断是否属于初始化状态</span></span><br><span class="line">    <span class="comment">// jnz     short loc_41185F</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+arg_0]</span></span><br><span class="line">    <span class="comment">// mov     dword_41B14C, eax            ; 初始化</span></span><br><span class="line">    <span class="comment">// push    offset dword_41B150</span></span><br><span class="line">    <span class="comment">// call    j___Init_thread_footer       ; 保证局部的静态对象的初始化</span></span><br><span class="line">    <span class="comment">// add     esp, 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, snNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ShowStatic(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>堆变量</em></strong></p>
</li>
<li><p>确定变量空间属于堆空间只要找到两个关键点</p>
<ul>
<li>空间申请：malloc 与 new</li>
<li>空间释放：free 与 delete</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pCharMalloc = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// push    0Ah                  ; Size</span></span><br><span class="line"><span class="comment">// call    ds:__imp_malloc</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> *pCharNew = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// push    0Ah                  ; Size</span></span><br><span class="line"><span class="comment">// call    j_unknown_libname_5  ; 跟进去可以发现，最后还是调用了 __imp_malloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pCharMalloc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(pCharMalloc);</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+Memory]</span></span><br><span class="line">    <span class="comment">// push    eax             ; Memory</span></span><br><span class="line">    <span class="comment">// call    ds:free</span></span><br><span class="line">    </span><br><span class="line">    pCharMalloc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pCharNew != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[]pCharNew;</span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+var_EC]</span></span><br><span class="line">    <span class="comment">// push    ecx             ; void *</span></span><br><span class="line">    <span class="comment">// call    sub_411258       ; __imp__free_dbg</span></span><br><span class="line">    </span><br><span class="line">    pCharNew = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><ul>
<li><p><strong><em>数组在函数内</em></strong></p>
<ul>
<li>数组中的数据在内存中的存储是线性连续的，其数据排列顺序由低地址到高地址，数组名称表示该数组的首地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nArr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// mov     [ebp+var_18], 1</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_14], 2</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_10], 3</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_C], 4</span></span><br><span class="line"><span class="comment">// mov     [ebp+var_8], 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>数组作为参数</em></strong></p>
<ul>
<li>数组作为函数形参时，函数参数中保存的是数组的首地址，是一个指针变量</li>
<li>虽然参数是指针变量，但需要特别注意，实参数组名为常量值，而指针或形参数组为变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">char</span> szBuffer[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    strcpy_s(szBuffer, <span class="number">12</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="comment">// push    offset aHelloWorld ; &quot;Hello World&quot;   ; 获取常量首地址，并将此地址压入栈中作为 strcpy_s 参数</span></span><br><span class="line">    <span class="comment">// push    0Ch              ; SizeInBytes</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+Dst]   ; 取函数参数 szBuffer 地址存入 eax 中</span></span><br><span class="line">    <span class="comment">// push    eax              ; 将 eax 压栈作为 strcpy_s 参数</span></span><br><span class="line">    <span class="comment">// call    ds:__imp_strcpy_s</span></span><br><span class="line">    <span class="comment">// add     esp, 0Ch</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(szBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szHello[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// mov     dword ptr [ebp+Dst], eax</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_18], eax</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_14], eax</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_10], eax</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_C], eax</span></span><br><span class="line">    </span><br><span class="line">    Show(szHello);</span><br><span class="line">    <span class="comment">// lea     eax, [ebp+Dst]   ; 取数组首地址存入 ecx</span></span><br><span class="line">    <span class="comment">// push    eax              ; 将 eax 作为参数压栈</span></span><br><span class="line">    <span class="comment">// call    sub_411389       ; 调用 Show 函数</span></span><br><span class="line">    <span class="comment">// add     esp, 4           ; 平衡参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>数组作为返回值</em></strong></p>
<ul>
<li>数组作为参数时，其定义所在的作用域必然在函数调用以外，在调用之前已经存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">RetArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szBuff[] = &#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// ; 字符串数组初始化为指针</span></span><br><span class="line">    <span class="comment">// mov     eax, ds:dword_417B30</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_14], eax</span></span><br><span class="line">    <span class="comment">// mov     ecx, ds:dword_417B34</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_10], ecx</span></span><br><span class="line">    <span class="comment">// mov     edx, ds:dword_417B38</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_C], edx</span></span><br><span class="line">    <span class="comment">// lea     eax, [ebp+var_14]    ; 使用 eax 保存数组首地址，作为函数返回值，虽然 eax 保存的地址存在，但是当函数结束调用后，此地址中的数据将不稳定，在进行其他对栈空间的读写操作时可能破坏此数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> szBuff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RetArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h2><ul>
<li><p><strong><em>this指针</em></strong></p>
<ul>
<li>利用寄存器 <code>ecx</code> 保存对象的首地址，并以寄存器传参的方式传递到成员函数中，这便是 this 指针的由来</li>
<li>所有成员函数都有一个隐藏参数，即自身类型的指针，这便是 this 指针，将这一的默认调用约定称为 <code>thiscall</code> </li>
<li>在成员函数中访问数据成员也是通过 this 指针间接访问的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// push    ebp</span></span><br><span class="line">    <span class="comment">// mov     ebp, esp</span></span><br><span class="line">    <span class="comment">// sub     esp, 0CCh</span></span><br><span class="line">    <span class="comment">// push    ebx</span></span><br><span class="line">    <span class="comment">// push    esi</span></span><br><span class="line">    <span class="comment">// push    edi</span></span><br><span class="line">    <span class="comment">// push    ecx                  ; ecx 中保存了对象 test 的首地址</span></span><br><span class="line">    <span class="comment">// lea     edi, [ebp+var_CC]</span></span><br><span class="line">    <span class="comment">// mov     ecx, 33h</span></span><br><span class="line">    <span class="comment">// mov     eax, 0CCCCCCCCh</span></span><br><span class="line">    <span class="comment">// rep stosd</span></span><br><span class="line">    <span class="comment">// pop     ecx                  ; 还原 ecx</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_8], ecx     ; 将 ecx 中的数据存入 ebp+var_8 处，该地址保存着调用对象的首地址，即 this 指针</span></span><br><span class="line">    </span><br><span class="line">        m_nInt = nNumber;</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+var_8] ; 取出对象的首地址并存入到 eax</span></span><br><span class="line">        <span class="comment">// mov     ecx, [ebp+arg_0] ; 取出参数中的数据并保存到 ecx 中</span></span><br><span class="line">        <span class="comment">// mov     [eax], ecx       ; 给 m_nInt 赋值 --&gt; mov dword ptr [eax+0],eax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest test;</span><br><span class="line">    test.SetNumber(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// push    5                    ; 压入参数</span></span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_C]     ; 取出对象 test 的首地址存入 ecx 中</span></span><br><span class="line">    <span class="comment">// call    sub_4112EE           ; 调用成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 <code>thiscall</code> 调用方式的成员函数的要点分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea ecx, [mem]          ; 取对象首地址并存入 ecx 中</span><br><span class="line">call FUN_ADDRESS        ; 调用成员函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong><em>对象作为函数参数</em></strong></p>
<ul>
<li>数组变量的名称代表数组的首地址，而对象的变量名称却不能代表对象的首地址，传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份，将复制的数据作为形参传递到调用函数中使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nOne;</span><br><span class="line">    <span class="keyword">int</span> m_nTwo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowFUnTest</span><span class="params">(CTest test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, test.m_nOne, test.m_nTwo);</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+arg_4]     ; 取出数据成员 m_nTwo 作为 printf 函数的第三个参数</span></span><br><span class="line">    <span class="comment">// push    eax</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+arg_0]     ; 取出数据成员 m_nOne 作为 printf 函数的第二个参数</span></span><br><span class="line">    <span class="comment">// push    ecx</span></span><br><span class="line">    <span class="comment">// push    offset aDD      ; &quot;%d %d&quot;</span></span><br><span class="line">    <span class="comment">// call    sub_41104B</span></span><br><span class="line">    <span class="comment">// add     esp, 0Ch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest test;</span><br><span class="line">    test.m_nOne = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// mov     [ebp+var_C], 1</span></span><br><span class="line">    </span><br><span class="line">    test.m_nTwo = <span class="number">2</span>;</span><br><span class="line">     <span class="comment">// mov     [ebp+var_8], 2</span></span><br><span class="line">    </span><br><span class="line">    ShowFUnTest(test);</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_8]</span></span><br><span class="line">    <span class="comment">// push    eax                  ; 传入数据成员 m_nTwo</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+var_C]</span></span><br><span class="line">    <span class="comment">// push    ecx                  ; 传入数据成员 m_nOne</span></span><br><span class="line">    <span class="comment">// call    sub_4110E6</span></span><br><span class="line">    <span class="comment">// add     esp, 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><em>对象作为返回值</em></strong></p>
<ul>
<li>对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">    <span class="keyword">int</span> m_nArry[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CTest <span class="title">GetCTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest testObj;</span><br><span class="line">    testObj.m_nNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        testObj.m_nArry[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> testObj;</span><br><span class="line">    <span class="comment">// mov     ecx, 0Bh             ; 设置循环次数</span></span><br><span class="line">    <span class="comment">// lea     esi, [ebp+var_30]    ; 获取局部对象的首地址</span></span><br><span class="line">    <span class="comment">// mov     edi, [ebp+arg_0]     ; 获取返回对象的首地址</span></span><br><span class="line">    <span class="comment">// rep movsd                    ; 将局部对象中的数据复制到返回对象中</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+arg_0]     ; 获取返回对象的首地址并保存到 eax 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest test;</span><br><span class="line">    test = GetCTest();</span><br><span class="line">    <span class="comment">// lea     eax, [ebp+var_158]       ; 获取返回对象的栈空间首地址</span></span><br><span class="line">    <span class="comment">// push    eax                      ; 将返回对象的首地址压入栈中，用于保存返回对象的数据</span></span><br><span class="line">    <span class="comment">// call    sub_411389</span></span><br><span class="line">    <span class="comment">// add     esp, 4</span></span><br><span class="line">    <span class="comment">// mov     ecx, 0Bh                 ; 设置循环次数</span></span><br><span class="line">    <span class="comment">// mov     esi, eax                 ; 将返回对象的首地址存入 esi</span></span><br><span class="line">    <span class="comment">// lea     edi, [ebp+var_124]       ; 获取临时对象的首地址</span></span><br><span class="line">    <span class="comment">// rep movsd</span></span><br><span class="line">    <span class="comment">// mov     ecx, 0Bh                 ; 重新设置次数</span></span><br><span class="line">    <span class="comment">// lea     esi, [ebp+var_124]       ; 获取临时对象的首地址</span></span><br><span class="line">    <span class="comment">// lea     edi, [ebp+var_30]        ; 获取对象 test 的首地址</span></span><br><span class="line">    <span class="comment">// rep movsd</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, test.m_nNumber, test.m_nArry[<span class="number">0</span>], test.m_nArry[<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul>
<li><p><strong>构造函数出现的时机</strong></p>
<ul>
<li><p><strong><em>局部对象</em></strong></p>
<ul>
<li>当对象产生时，便有可能引发构造函数的调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lea     ecx, [ebp+var_C] ; 取得对象首地址，传入 ecx 作为参数</span></span><br><span class="line">        <span class="comment">// call    sub_411302       ; 调用构造函数</span></span><br><span class="line">    </span><br><span class="line">        m_nNumber = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+var_8]     ; eax 中保存了对象的首地址</span></span><br><span class="line">        <span class="comment">// mov     dword ptr [eax], 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CNumber num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>识别局部对象的构造函数的条件<ul>
<li>该成员函数是这个对象在作用域内调用的第一个函数，根据 this 指针即可以区分每个对象</li>
<li>这个函数返回 this 指针</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><em>堆对象</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        m_nNumber = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CNumber *pNum = <span class="literal">NULL</span>;</span><br><span class="line">    pNum = <span class="keyword">new</span> CNumber;</span><br><span class="line">    <span class="comment">// push    4               ; Size   申请堆内存</span></span><br><span class="line">    <span class="comment">// call    j_??2@YAPAXI@Z  ; operator new(uint)</span></span><br><span class="line">    <span class="comment">// add     esp, 4</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_EC], eax    ; 使用临时变量保存 new 返回值</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_4], 0       ; [ebp+var_4] 保存申请堆空间的次数</span></span><br><span class="line">    <span class="comment">// cmp     [ebp+var_EC], 0      ; 检测堆内存是否申请成功</span></span><br><span class="line">    <span class="comment">// jz      short loc_411921</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+var_EC]    </span></span><br><span class="line">    <span class="comment">// call    sub_411375           ; 调用构造函数</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_F4], eax    ; 构造函数返回 this 指针，保存到临时变量[ebp+var_F4]中</span></span><br><span class="line">    <span class="comment">// jmp     short loc_41192B</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_F4], 0      ; 申请堆空间失败，设置指针值为 NULL</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_F4]</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_E0], eax</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_4], 0FFFFFFFFh</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+var_E0]</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_14], ecx</span></span><br><span class="line">    </span><br><span class="line">    pNum-&gt;m_nNumber = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_14]    ; eax 得到 this 指针</span></span><br><span class="line">    <span class="comment">// mov     dword ptr [eax], 2   ; 为成员变量 m_nNum 赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><em>参数对象</em></strong></p>
<ul>
<li>当对象作为函数参数时，调用一个特殊的构造函数–拷贝构造函数，该构造函数只有一个参数，类型为对象的引用</li>
</ul>
</li>
<li><p><strong><em>返回对象</em></strong></p>
</li>
<li><p><strong><em>全局对象</em></strong></p>
<ul>
<li><p>构造函数会早于main函数的开始</p>
</li>
<li><p>构造函数会在<code>_initterm</code>中被调用</p>
</li>
<li><p>编写源码，在全局对象的构造函数中设置断点，查看调用堆栈</p>
<p><img data-src="/images/asm/1.png"></p>
</li>
<li><p>定位到 <code>_initterm</code> 函数，查看其中的内容</p>
<p><img data-src="/images/asm/2.png"></p>
</li>
<li><p>根据函数的实现，将*<strong>特征码*</strong>提取出来，不同环境下的特征码可能不同</p>
<p><img data-src="/images/asm/3.png"></p>
</li>
<li><p>找到 <code>__scrt_common_main_seh</code> 函数，在调用 invoke_main 之前，它调用了 <code>initterm</code> 函数，根据特征，两组 push + push _ call 的第二组</p>
</li>
</ul>
</li>
<li><p><strong><em>静态对象</em></strong></p>
</li>
</ul>
<ul>
<li><p><strong>析构函数的出现时机</strong></p>
<ul>
<li><p><strong><em>局部对象</em></strong>：作用域结束前调用析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        m_nNumber = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~CNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~CNumber()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CNumber number;</span><br><span class="line">    <span class="comment">// call    sub_411320</span></span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_C] ; 调用析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><em>堆对象</em></strong>：释放堆空间前调用析构函数</p>
</li>
<li><p><strong><em>参数对象</em></strong>：退出函数前，调用参数对象的析构函数</p>
</li>
<li><p><strong><em>返回对象</em></strong>：如无对象引用定义，退出函数后，调用返回对象的析构函数，否则与对象引用的作用域一致</p>
</li>
<li><p><strong><em>全局对象</em></strong>：main 函数退出后调用析构函数</p>
<ul>
<li><p>通过在析构函数设置断点进行栈回溯</p>
<p><img data-src="/images/asm/4.png"></p>
</li>
<li><p>分析函数获取*<strong>特征码*</strong>(exe!_execute_onexit_table::__l2<lambda>())</lambda></p>
<p><img data-src="/images/asm/5.png"></p>
</li>
</ul>
</li>
<li><p><strong><em>静态对象</em></strong>：main 函数退出后调用析构函数</p>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>一个类对象的内存中可能存在多个虚表指针</li>
<li>虚函数表一般存在只读数据段（<code>.rdata</code>）</li>
<li>程序编译时，会自动生成虚函数表</li>
<li>如果有继承关系，父类和子类虚函数一样，也会有两个虚函数表，他们的虚函数表指针都是在各自的构造函数中初始化的</li>
<li>构造函数中会初始化本类的虚函数表指针</li>
<li>当父类指针指向子类对象时，虚函数调用才会访问虚函数表</li>
</ul>
<ul>
<li><p><strong><em>虚函数的机制</em></strong></p>
<ul>
<li>对于函数构造函数的类而言，其虚表初始化过程中和默认构造函数相同，都是以对象首地址的前4字节数据保存虚表的首地址</li>
<li>在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其他代码访问这个对象的虚函数时，会根据对象的首地址，取出对应虚表元素。当函数被调用时，会间接访问虚表，得到对应的虚函数首地址，并调用执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CObj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ; CObj::CObj        <span class="comment">// 编译器为类提供的默认构造函数</span></span><br><span class="line">    <span class="comment">// pop     ecx                  ; 还原 this 指针</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_8], ecx     ; [ebp+var_8] 存储 this 指针</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_8]     ; 取出 this 指针并保存到 eax 中，这个地址将会作为指针保存到虚表的首地址中</span></span><br><span class="line">    <span class="comment">// mov     dword ptr [eax], offset ??_7CObj@@6B@ ; const CObj::`vftable&#x27; 取虚表的首地址，保存到虚表指针中</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_8]     ; 返回对象首地址</span></span><br><span class="line">    <span class="comment">// pop     edi</span></span><br><span class="line">    <span class="comment">// pop     esi</span></span><br><span class="line">    <span class="comment">// pop     ebx</span></span><br><span class="line">    <span class="comment">// mov     esp, ebp</span></span><br><span class="line">    <span class="comment">// pop     ebp</span></span><br><span class="line">    <span class="comment">// retn</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_nNumber = nNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CObj obj;</span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_10]    ; 获取对象首地址</span></span><br><span class="line">    <span class="comment">// call    sub_4111E5           ; 调用虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当直接使用对象调用自身的虚函数时，没有必要查表访问。因为已经明确调用的是自身的成员函数，根本没有构成多态性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CObj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_nNumber = nNumber;</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+var_8]</span></span><br><span class="line">        <span class="comment">// mov     ecx, [ebp+arg_0]</span></span><br><span class="line">        <span class="comment">// mov     [eax+4], ecx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CObj obj;</span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_10]</span></span><br><span class="line">    <span class="comment">// call    sub_4111E5</span></span><br><span class="line">    </span><br><span class="line">    obj.SetNumber(argc);</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+argc]      </span></span><br><span class="line">    <span class="comment">// push    eax</span></span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_10]</span></span><br><span class="line">    <span class="comment">// call    sub_41132F       ; 直接调用函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><em>如何判断是否是虚函数</em></strong></p>
<ul>
<li>类中隐式定义了一个数据成员</li>
<li>该数据成员在首地址处，占4字节</li>
<li>构造函数会将此数据成员初始化为某个数组的首地址</li>
<li>这个地址属于数据区，是相对固定的地址</li>
<li>在这个数组内，每个元素都函数指针</li>
<li>函数被调用时，第一个参数必然是 this 指针（注意调用约定）</li>
<li>在函数内部，很有可能会对 this 指针使用相对间接的访问方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release 版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CObj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CObj()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CObj&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CObj(<span class="keyword">int</span> nInt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CObj(int nInt) %d&quot;</span>, nInt);</span><br><span class="line">    &#125;</span><br><span class="line">    CObj(<span class="keyword">const</span> <span class="keyword">char</span> *pChar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CObj(char *pChar) %s&quot;</span>, pChar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~CObj()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ~CObj()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对象首地址：0x%08x&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CObj g_obj_void;</span><br><span class="line"><span class="function">CObj <span class="title">g_obj_int</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">CObj <span class="title">g_obj_lpChar</span><span class="params">(<span class="string">&quot;hello World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_obj_void.Show();</span><br><span class="line">    g_obj_int.Show();</span><br><span class="line">    g_obj_lpChar.Show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push    offset off_40301C</span></span><br><span class="line"><span class="comment">// push    offset unk_402150</span></span><br><span class="line"><span class="comment">// call    sub_401070</span></span><br><span class="line"><span class="comment">// push    offset off_403020</span></span><br><span class="line"><span class="comment">// push    offset unk_402150</span></span><br><span class="line"><span class="comment">// call    sub_401070</span></span><br><span class="line"><span class="comment">// push    offset off_403018</span></span><br><span class="line"><span class="comment">// push    offset unk_402150</span></span><br><span class="line"><span class="comment">// call    sub_401070</span></span><br><span class="line"><span class="comment">// add     esp, 18h</span></span><br><span class="line"><span class="comment">// xor     eax, eax</span></span><br><span class="line"><span class="comment">// retn</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong><em>使用父类指针(引用)指向子类对象调用虚函数形成了动态联编</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CObj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;show\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hook_show\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义了一个对象直接调用了构造函数，没有产生动态联编</span></span><br><span class="line">    CObj obj; </span><br><span class="line">    <span class="comment">// 对象使用 lea 获取地址</span></span><br><span class="line">    <span class="comment">// lea ecx, dword ptr [ebp-xxx]</span></span><br><span class="line">    <span class="comment">// call show</span></span><br><span class="line">    obj.show();</span><br><span class="line"></span><br><span class="line">    CObj* pObj = &amp;obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用父类指针(引用)指向子类对象调用虚函数形成了动态联编</span></span><br><span class="line">    pObj-&gt;show(); <span class="comment">// 指针使用 Mov 获取指向的内容(地址)</span></span><br><span class="line">    <span class="comment">// mov eax, dword ptr[ebp-xxx]       this</span></span><br><span class="line">    <span class="comment">// mov eax, dword ptr[eax]             虚函数表指针</span></span><br><span class="line">    <span class="comment">// mov eax, dword ptr[eax+4*0]       虚函数</span></span><br><span class="line">    <span class="comment">// mov ecx, dword ptr[ebp-xxx]       this</span></span><br><span class="line">    <span class="comment">// call eax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="继承和多重继承"><a href="#继承和多重继承" class="headerlink" title="继承和多重继承"></a>继承和多重继承</h2><ul>
<li><p><strong><em>识别类和类之间的关系</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CBase()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CBase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CBase()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~CBase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_nBase = nNumber;</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+var_8]     ; 还原 this 指针</span></span><br><span class="line">        <span class="comment">// mov     ecx, [ebp+arg_0]     ; ecx 得到参数</span></span><br><span class="line">        <span class="comment">// mov     [eax], ecx           ; 这里的 [eax] 相当于 [this + 0]，参考内存结构，是父类成员 m_nBase</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_nBase;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span> :</span> <span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ; CTest::CTest 提供的默认构造</span><br><span class="line">    <span class="comment">// pop     ecx                  ; 还原 this 指针</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_8], ecx</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+var_8]     ; 以子类对象首地址作为父类的this指针，调用父类构造函数</span></span><br><span class="line">    <span class="comment">// call    sub_41119A</span></span><br><span class="line">    <span class="comment">// mov     eax, [ebp+var_8]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SetNumber(nNumber);</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+arg_0]     ; 访问参数 nNumber 并保存到 eax 中</span></span><br><span class="line">        <span class="comment">// push    eax</span></span><br><span class="line">        <span class="comment">// mov     ecx, [ebp+var_8]     ; 由于 this 指针同时也是对象中父类部分的首地址，因此在调用父类成员函数时，this 指针的值和子类对象等同</span></span><br><span class="line">        <span class="comment">// call    sub_41102D</span></span><br><span class="line">        </span><br><span class="line">        m_nTest = nNumber + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// mov     eax, [ebp+arg_0]     </span></span><br><span class="line">        <span class="comment">// add     eax, 1</span></span><br><span class="line">        <span class="comment">// mov     ecx, [ebp+var_8]     ; ecx 获得 this 指针</span></span><br><span class="line">        <span class="comment">// mov     [ecx+4], eax         ; 子类成员 m_nTest 的地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, GetNumber());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, m_nTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_nTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest test;</span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_1C]    ; 获取对象首地址作为 this 指针</span></span><br><span class="line">    <span class="comment">// call    sub_411172           ; 调用类 CTest 的构造函数，编译器提供了默认的构造函数</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_4], 0</span></span><br><span class="line">    </span><br><span class="line">    test.ShowNumber(argc);</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+argc]</span></span><br><span class="line">    <span class="comment">// push    eax</span></span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_1C]    ; 调用 CTest 成员函数，传入 this 指针</span></span><br><span class="line">    <span class="comment">// call    sub_411320</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_E8], 0</span></span><br><span class="line">    <span class="comment">// mov     [ebp+var_4], 0FFFFFFFFh</span></span><br><span class="line">    <span class="comment">// lea     ecx, [ebp+var_1C]</span></span><br><span class="line">    <span class="comment">// call    sub_411064           ; 调用类 CTest 的析构函数，编译器提供了默认的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CPerson() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~CPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChinese</span> :</span> <span class="keyword">public</span> CPerson</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CChinese() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~CChinese() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAmerican</span> :</span> <span class="keyword">public</span> CPerson</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CAmerican() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~CAmerican() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Speak American&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGerman</span> :</span> <span class="keyword">public</span> CPerson</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CGerman() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~CGerman() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowSpeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Speak German&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">(CPerson *pPerson)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pPerson-&gt;ShowSpeak();</span><br><span class="line">    <span class="comment">// mov     eax, [ebp+arg_0]     ; eax 获取参数 pPerson的值</span></span><br><span class="line">    <span class="comment">// mov     edx, [eax]           ; 取虚表首地址并传递给 edx</span></span><br><span class="line">    <span class="comment">// mov     esi, esp</span></span><br><span class="line">    <span class="comment">// mov     ecx, [ebp+arg_0]     ; 设置 this 指针</span></span><br><span class="line">    <span class="comment">// mov     eax, [edx+4]</span></span><br><span class="line">    <span class="comment">// call    eax                  ; 利用虚表指针edx，间接调用函数，第一个声明的虚函数是析构函数，第二个声明的虚函数是ShowSpeak，所以ShowSpeak在虚表的位置排第二，[edx+4] 即 ShowSpeak 的函数地址</span></span><br><span class="line">    <span class="comment">// cmp     esi, esp</span></span><br><span class="line">    <span class="comment">// call    j___RTC_CheckEsp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CChinese chinese;</span><br><span class="line">    CAmerican american;</span><br><span class="line">    CGerman german;</span><br><span class="line">    Speak(&amp;chinese);</span><br><span class="line">    Speak(&amp;american);</span><br><span class="line">    Speak(&amp;german);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>静态函数没有this指针，没有ecx传参</li>
<li>静态函数的两种调用在反汇编都是一样的</li>
<li>友元函数一般参数都某个对象，或对象指针</li>
<li>访问或者修改成员变量，一般都是使用this指针加上偏移来实现</li>
<li>获取成员变量的函数，一般返回值是从this指针指向的内存空间中获取</li>
<li>设置成员变量的函数，一般参数传递进去之后会修改 this 指针所指向的内存空间</li>
</ul>
<h1 id="数据结构的逆向"><a href="#数据结构的逆向" class="headerlink" title="数据结构的逆向"></a>数据结构的逆向</h1><h2 id="字符串对象-CString"><a href="#字符串对象-CString" class="headerlink" title="字符串对象 CString"></a>字符串对象 CString</h2><ul>
<li><p>CString 大小是4字节，初始化会依赖两个函数，初始化空间+构造函数</p>
<p><img data-src="/images/asm/6.png"></p>
</li>
</ul>
<h2 id="字符串对象-string"><a href="#字符串对象-string" class="headerlink" title="字符串对象 string"></a>字符串对象 string</h2><ul>
<li><p>string 大小是 28字节，其中的第二个元素是一个联合体，当字符串长度大于15时，会存在一个指针，指向实际的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_string</span>* <span class="title">self</span>;</span>        <span class="comment">// 指向自己的指针</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* ptr;                <span class="comment">// 当数据大于15字节的时候</span></span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">0x10</span>];            <span class="comment">// 当数据小于16字节的时候</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> length;                    <span class="comment">// 当前占用的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;                    <span class="comment">// 指向的堆空间的大小(最多能存储多少)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="vector-对象"><a href="#vector-对象" class="headerlink" title="vector 对象"></a>vector 对象</h2><ul>
<li><p>vector 占用的大小是16字节，初始化使用两个函数，分别是分配空间函数和构造函数</p>
</li>
<li><p>第一个字段是一个指向自己的指针</p>
</li>
<li><p>第二个字段直接指向数据的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">my_vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_vector</span>* <span class="title">self</span>;</span>        <span class="comment">// 指向自己</span></span><br><span class="line">    T* <span class="built_in">begin</span>;                    <span class="comment">// 指向堆空间起始位置</span></span><br><span class="line">    T* data_end;                <span class="comment">// 指向数据的结尾部分</span></span><br><span class="line">    T* heap_end;                <span class="comment">// 指向堆空间的结尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="list-对象"><a href="#list-对象" class="headerlink" title="list 对象"></a>list 对象</h2><ul>
<li><p>list 是一个双向循环链表，占用了 0x0C的空间，分别保存了自己的地址，头节点的地址以及元素的个数</p>
</li>
<li><p>第一个字段是一个指向自己的指针</p>
</li>
<li><p>第二个字段是头节点</p>
</li>
<li><p>第三个字段存放元素个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">my_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_node</span>* <span class="title">next</span>;</span>        <span class="comment">// 指向下一个</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_node</span>* <span class="title">prev</span>;</span>        <span class="comment">// 指向前一个</span></span><br><span class="line">    T element;                    <span class="comment">// 数据域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器结构体</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">my_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_list</span>* <span class="title">self</span>;</span>        <span class="comment">// 指向自己的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_node</span>&lt;T&gt;* <span class="title">head</span>;</span>    <span class="comment">// 头节点，不存储数据</span></span><br><span class="line">    <span class="keyword">int</span> length;                    <span class="comment">// 元素个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li><p>迭代器占用了 12 字节空间，第一个指针指向了一个结构体，保存了自己的地址，又保存了被关联容器的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* target;        <span class="comment">// 指向的类型是不固定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_iterator</span>* <span class="title">self</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span>* <span class="title">point</span>;</span>            <span class="comment">// 自己和关联的容器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_iterator</span>* <span class="title">prev</span>;</span>    <span class="comment">// 前一个迭代器</span></span><br><span class="line">    <span class="keyword">void</span>* node;                    <span class="comment">// 具体的的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="MFC-程序的逆向"><a href="#MFC-程序的逆向" class="headerlink" title="MFC 程序的逆向"></a>MFC 程序的逆向</h1><ul>
<li><p>调用堆栈窗口，提取特征码</p>
<ul>
<li>不同版本的 VS 对应的特征码不同，所以需要自己分析，不同的事件对应的特征码也是不同</li>
</ul>
<p><img data-src="/images/asm/7.png"></p>
</li>
<li><p>在OD中右键 –&gt;  查找 –&gt; 所有命令</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《C++反汇编与逆向分析技术揭秘》</li>
</ol>

    </div>

    
    
    
	
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Demons
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.zhubokai.com/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html" title="C++反汇编分析">https://www.zhubokai.com/C++反汇编分析.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E9%80%86%E5%90%91/" rel="tag"><i class="fa fa-tag"></i> 逆向</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.html" rel="prev" title="不同语言程序的特征">
      <i class="fa fa-chevron-left"></i> 不同语言程序的特征
    </a></div>
      <div class="post-nav-item">
    <a href="/%E8%84%B1%E5%A3%B3%E5%85%A5%E9%97%A8-%E5%AF%BB%E6%89%BEOEP.html" rel="next" title="寻找OEP">
      寻找OEP <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8IDA%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F"><span class="nav-text">使用IDA分析程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E8%BE%9F%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7"><span class="nav-text">开辟函数栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="nav-text">保存寄存器环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">初始化局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%89%E5%85%A8cookie"><span class="nav-text">初始化安全cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%98%AF%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-text">检测是否是库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1"><span class="nav-text">检测堆栈平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="nav-text">恢复寄存器环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E8%B6%8A%E7%95%8C"><span class="nav-text">检测数组是否越界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%A0%88%E5%B8%A7"><span class="nav-text">关闭栈帧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="nav-text">C++反汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-text">基本常量类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">全局变量和局部变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-text">数组和指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="nav-text">结构体和类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数和析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">继承和多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%86%E5%90%91"><span class="nav-text">数据结构的逆向</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1-CString"><span class="nav-text">字符串对象 CString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1-string"><span class="nav-text">字符串对象 string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%AF%B9%E8%B1%A1"><span class="nav-text">vector 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E5%AF%B9%E8%B1%A1"><span class="nav-text">list 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MFC-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%86%E5%90%91"><span class="nav-text">MFC 程序的逆向</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Demons" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Demons</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Demons-t" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Demons-t" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github-alt fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kai.huan.demons@gmail.com" title="E-Mail → mailto:kai.huan.demons@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.notion.so/App-2f4b23277b5748fba56f1a9d9d10ce52" title="notion → https:&#x2F;&#x2F;www.notion.so&#x2F;App-2f4b23277b5748fba56f1a9d9d10ce52" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-cat fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://hugang-first.github.io/" title="http:&#x2F;&#x2F;hugang-first.github.io&#x2F;" rel="external nofollow noopener noreferrer" target="_blank">胡港</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Demons</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">45k</span>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f2e451b7cef91a2" async="async"></script>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 26642,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>





  <script src="//code.tidio.co/8usoipuhv0iwfwugvjfoezyyxejjs12b.js"></script>







  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.zhubokai.com/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html',]
      });
      });
  </script>

   

 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>


 
<script async src="//code.tidio.co/8usoipuhv0iwfwugvjfoezyyxejjs12b.js"></script>


 
<script>
  (function(h,o,t,j,a,r){
    h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
    h._hjSettings={hjid:1934467,hjsv:6};
    a=o.getElementsByTagName('head')[0];
    r=o.createElement('script');r.async=1;
    r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
    a.appendChild(r);
  })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>




  <script src="/js/wobblewindow.js"></script>
  <script>
    //只在桌面版网页启用特效
    if( window.innerWidth > 768  ){
      $(document).ready(function () {
        

        

        
      });
    }
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'uKBH8r2O8Fr42ap3axemmi2O-gzGzoHsz',
      appKey     : 'cku5uA0Yym3EWfUIGhrI7Xrb',
      placeholder: "Just go go",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

<!--动态线条背景-->
<script type="text/javascript" color="220,220,220" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<!-- 雪花特效 -->
<script type="text/javascript" src="\js\snow.js"></script>